let setPosition: (Browser.htmlElement, Shapes.point) => unit = %raw(`
  function(element, position) {
    Object.assign(element.style, {
      left: position.x + "px",
      top: position.y + "px",
    });
  }
`)

type sortableItem = {
  name: string,
  value: int,
}

module Component = {
  open Emotion

  let container = css(`
    display: flex;
    flex-direction: column;

    touch-action: none;
  `)

  let item = css(`
    height: 2rem;

    border: 1px solid;
  `)

  let dropZone = css(`
    display: flex;
    align-items: center;

    height: 1rem;
    
    &.dragOver::before {
      content: "";
      background: red;
      height: 2px;
      display: block;
      width: 100%;
    }
  `)

  let draggable = css(`
    position: fixed;
    width: 2rem;
    height: 2rem;

    background: gray;
  `)

  type draggingItem<'a> = {
    item: Browser.htmlElement,
    offsetX: int,
    offsetY: int,
  }

  @react.component
  let make = () => {
    let containerRef = React.useRef(Js.Nullable.null)
    let draggingItem = React.useRef(None)
    let dropZones = React.useRef([])

    let (options, setOptions) = React.useState(_ => [
      {name: "zehn", value: 10},
      {name: "null", value: 0},
      {name: "acht", value: 8},
    ])

    let onPointerDown = e => {
      let item: Browser.htmlElement = ReactEvent.Pointer.currentTarget(e)->Obj.magic
      let cbr = item.getBoundingClientRect(.)

      let offsetX = ReactEvent.Pointer.pageX(e) - cbr.x
      let offsetY = ReactEvent.Pointer.pageY(e) - cbr.y

      draggingItem.current = Some({item: item, offsetX: offsetX, offsetY: offsetY})

      dropZones.current =
        containerRef.current
        ->Obj.magic
        ->Browser.querySelectorAll("." ++ dropZone)
        ->Belt.Array.map(element => (element, element.getBoundingClientRect(.)))
    }

    let onPointerUp = e => {
      let point: Shapes.point = {
        x: ReactEvent.Pointer.pageX(e),
        y: ReactEvent.Pointer.pageY(e),
      }

      let dropZoneIndex =
        dropZones.current->Belt.Array.getIndexBy(((_, rect)) => Shapes.insideRect(point, rect))

      let value = 25
      let items = [20, 30]

      switch dropZoneIndex {
      | Some(index) => {
          let itemBefore = Belt.Array.get(items, index - 1)
          let itemAfter = Belt.Array.get(items, index)

          let correct = switch (itemBefore, itemAfter) {
          // first
          | (None, Some(after)) => value < after

          // between
          | (Some(before), Some(after)) => value > before && value < after

          // last
          | (Some(before), None) => value > before

          // error
          | (None, None) => false
          }

          Js.log(correct)
        }
      | None => ()
      }

      draggingItem.current = None
    }

    let onPointerMove = e => {
      switch draggingItem.current {
      | Some(item) => {
          ReactEvent.Pointer.preventDefault(e)

          let x = ReactEvent.Pointer.pageX(e)
          let y = ReactEvent.Pointer.pageY(e)

          setPosition(item.item, {x: x - item.offsetX, y: y - item.offsetY})

          dropZones.current->Belt.Array.forEach(((dropZone, rect)) => {
            if x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height {
              dropZone.classList.add(. "dragOver")
            } else {
              dropZone.classList.remove(. "dragOver")
            }
          })
        }
      | None => ()
      }
    }

    <div>
      <div className=container ref={ReactDOM.Ref.domRef(containerRef)} onPointerMove onPointerUp>
        <div className=dropZone />
        <div className=item />
        <div className=dropZone />
        <div className=item />
        <div className=dropZone />
        <div className=draggable onPointerDown />
      </div>
      <div>
        {options
        ->Belt.Array.mapWithIndex((index, item) => <div key={Belt.Int.toString(index)}> {React.string(item.name)} </div>)
        ->React.array}
      </div>
    </div>
  }
}
